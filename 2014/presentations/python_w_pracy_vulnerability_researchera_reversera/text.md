# Python w pracy vulnerability researchera/reversera - Patryk Branicki, Radosław Matusiak

## Wprowadzenie

Prezentacja ma na celu przedstawienie wykorzystania języka programowania Python, jako jednego z narzędzi wspomagających pracę osoby zajmującej się analizą oprogramowania pod kątem odnajdywania błędów bezpieczeństwa w dostarczonym oprogramowaniu. Przez analizę oprogramowania mamy na myśli w większości przypadków podejście blackbox, czyli źródła aplikacji/systemu nie są dostępne i to warsztat pracy, doświadczenie oraz stworzone narzędzia umożliwiają odnajdywanie nieznanych dotychczas błędów.

## Słownik

* Vulnerability Researcher – Osoba zajmująca się analizą oprogramowania pod kątem odnajdywania błędów bezpieczeństwa.
* Reverser – Osoba zajmująca się analizą rewersyjną/wsteczną (Reverse Engineering).
* Vulnerability Research – Analiza oprogramowania pod kątem wykrywania błędów bezpieczeństwa.
* Vulnerability (vuln) – Podatność, błąd bezpieczeństwa. Przykładowo: DoS, LCE, RCE.
* DoS – Denial of Service
* LCE – Local Code Execution
* RCE – Remote Code Execution
* Reverse Engineering – Proces analizy kodu bez posiadania źródeł. Przykładowo mamy plik wynikowy EXE i dokonujemy analizy (statycznej bądź dynamicznej), w celu odtworzenia logiki aplikacji/algorytmów w niej użytych. Obszary zastosowania: Malware, Vulnerability Research, Cracking, Software Protection, DRM etc.
* Exploit - Konkretne wykorzystanie danej podatności. Click & Run.
* 0day - Nieznany szerszej grupie osób exploit. Pierwszy exploit wykorzystujący daną podatność.
* Fuzzing – Automatyczny proces testowania oprogramowania z wykorzystaniem poprawnych oraz niepoprawnych danych wejściowych (input).
* Input – Dane, na których pracuje aplikacja. Może to być plik TXT, AVI, HTML, JS, dane przesyłane po socketach, endpointach, argumenty funkcji etc. Generalnie dane aplikacji, na które ma wpływ użytkownik pracujący z daną aplikacją.
* Shellcode – Wstrzyknięty kod atakującego, który ma zostać wykonany podczas wykorzystania danej podatności.

## Debugging

Debugging w pracy reversera/researchera, niezależnie od wykonywanego zajęcia (security research, malware/anti-malware, cracking/software protections, vulnerability research) jest podstawowym narzędziem/umiejętnością wykorzystywaną w czasie pracy. Pozwala odtworzyć logikę/zastosowane algorytmy programu bez potrzeby posiadania plików źródłowych aplikacji. W przypadku odnalezienia nowej podatności, pozwala na dokładną analizę problemu oraz jego potencjalne wykorzystanie. Implementując konkretny exploit musimy znać dokładny stan aplikacji w czasie wywołania podatności. Przez „stan” rozumiem stan całej przestrzeni adresowej procesu: stack(s), heap(s), thread(s), moduły wykonywalne załadowane w procesie, a w szczególności ich adresy oraz właściwości, ich tablice IAT (import)/EAT(export), systemowe struktury danych pozwalające systemowi operacyjnemu na zarządzanie procesem i wykonywaniem wątków etc.

### Narzędzia

#### Win32 Debug API oraz CTYPES

System operacyjny Windows posiada bogate API umożliwiające pisanie własnych debuggerów dla R3 (Ring 3 – User Mode) [1]. Istnieje wiele powodów, dla których napisanie własnego debuggera jest często najrozsądniejszym rozwiązaniem. Debugger to nic innego jak swoisty nadzorca procesu, który może reagować, w zaprogramowany przez nas sposób, na zachodzące w procesie zdarzenia:

	* CREATE_PROCESS_DEBUG_EVENT
	* CREATE_THREAD_DEBUG_EVENT
	* EXCEPTION_DEBUG_EVENT
	* EXIT_PROCESS_DEBUG_EVENT
	* EXIT_THREAD_DEBUG_EVENT
	* LOAD_DLL_DEBUG_EVENT
	* OUTPUT_DEBUG_STRING_EVENT
	* UNLOAD_DLL_DEBUG_EVENT
	* RIP_EVENT

Jednym z najciekawszych zdarzeń z naszej perspektywy jest EXCEPTION_DEBUG_EVENT. Zostaje on wywołany przez system w przypadku np.: dzielenia przez zero, dostępu do nieprzydzielonej pamięci, bądź zatrzymaniu się na ustawionym przez nas breakpointcie [2].

Exception codes [3]:

	* EXCEPTION_ACCESS_VIOLATION
	* EXCEPTION_ARRAY_BOUNDS_EXCEEDED
	* EXCEPTION_BREAKPOINT
	* EXCEPTION_DATATYPE_MISALIGNMENT
	* EXCEPTION_FLT_DENORMAL_OPERAND
	* EXCEPTION_FLT_DIVIDE_BY_ZERO
	* EXCEPTION_FLT_INEXACT_RESULT
	* EXCEPTION_FLT_INVALID_OPERATION
	* EXCEPTION_FLT_OVERFLOW
	* EXCEPTION_FLT_STACK_CHECK
	* EXCEPTION_FLT_UNDERFLOW
	* EXCEPTION_ILLEGAL_INSTRUCTION
	* EXCEPTION_IN_PAGE_ERROR
	* EXCEPTION_INT_DIVIDE_BY_ZERO
	* EXCEPTION_INT_OVERFLOW
	* EXCEPTION_INVALID_DISPOSITION
	* EXCEPTION_NONCONTINUABLE_EXCEPTION
	* EXCEPTION_PRIV_INSTRUCTION
	* EXCEPTION_SINGLE_STEP
	* EXCEPTION_STACK_OVERFLOW

Dzięki własnemu debuggerowi, możemy w dowolny sposób nadzorować oraz modyfikować wykonywane w procesie wątki.

Z naszej perspektywy najbardziej interesujące są:
* Odczytanie/modyfikacja danych w pamięci.
* Nadzorowanie wyjątków i ich automatyczna analiza w przypadku sesji fuzzowania.
* Modyfikacje wykonywanego kodu.
* Monitorowanie wykonywania kodu.
* Wstrzykiwanie kodu.

Dzięki wykorzystaniu CTYPES, w skryptach możemy wykorzystywać wywołania natywnych Win32 API w skryptach Python.

#### PyDBG

PyDBG [4], stworzony przez Pedram Amini, jest niczym innym jak przyjemnym dla programisty wrapperem na Debug API napisanym w Pythonie. Umożliwia stworzenie małego, dedykowanego debuggera dosłownie w kilku linijkach kodu.

Funkcjonalność PyDBG:
* Zarządzanie software breakpoints
* Zarządzanie hardware breakpoints
* Zarządzanie memory breakpoints
* Zarządzanie uchwytami procesu
* Zarządzanie i manipulacja rejestrami procesora
* Zarządzanie modułami wykonywalnymi (ładowanie, odładowywanie)
* Mapowanie adresów VA na załadowane moduły wykonywalne
* Przetwarzanie debug events
* Podłączanie się do procesu i odłączanie (ang. process attach/detach)
* Disassemble
* Dump context
* Enumeracja modułów wykonywalnych w procesie
* Enumeracja procesów i wątków
* Tworzenie procesów
* Tworzenie wątków w procesie
* Kończenie procesów i wątków
* Otwieranie procesów i wątków
* Event handlery dla obsługi debug events
* Obsługa łańcuchów znakowych znajdujących się w pamięci procesu
* Zrzucanie snapshotu procesu
* Odczyt/zapis pamięci procesu
* Zatrzymywanie/wznawianie wątków w procesie
* Zarządzanie stosami
* Zarządzaniem stronami pamięci (zmiany flag: RWX)

#### PyDBG: Hooking

PyDBG umożliwia wygodne ustawianie breakpointów dla wykonywanych w procesie wątków. Dzięki temu mamy łatwą możliwość odczytu argumentów funkcji, zmiennych globalnych, zmiennych lokalnych, buforów danych alokowanych na stosie bądź stercie (ang. heap) oraz oczywiście ich modyfikacji. Hooking umożliwia wygodne nadzorowanie pracy procesu oraz analizę działania wykonywanego kodu. Dzięki możliwości zaprogramowania obsługi każdego interesującego nas zdarzenia, możemy wprowadzić dowolną logikę, która pozwala nam analizować skomplikowane przetwarzanie danych przez dany wątek.

#### PyDBG: Dynamiczne modyfikowanie kodu

Kolejnym krokiem, po odczytywaniu i modyfikowaniu danych używanych przez dany proces, jest nadzorowanie i modyfikacja kodu wykonywanego w danym wątku. Posiadamy możliwość reagowania na ustawione breakpointy, możemy dokonywać zmiany wartości rejestrów, zmiany wartości pamięci, zmieniać miejsce wykonania kodu, dokonywać zmiany decyzji o skokach warunkowych. Dodatkowo, jeśli sytuacja tego wymaga, możemy wstrzyknąć nasz kod w postaci shellcodu, bądź dodatkowej biblioteki, w której znajduje się nasz kod.

#### Immunity Debugger

Immunity Debugger [5] bazuje na debuggerze OllyDbg [6] stworzonym przez Oleh Yuschuk. Immunity Debugger rozszerza OllyDbg o interpreter Pythona wraz z pokaźnym API, umożliwiający tworzenie nowych narzędzi na powyższej platformie.

#### IDA & IDAPython

Podobnie jak w przypadku Immunity Debuggera, stworzenie pluginu IDAPython [7] otworzyło środowisko IDA [8] na łatwe tworzenie nowych narzędzi w Pythonie, wspomagających analizę modułów wykonywalnych.

## Budowa fuzzerów w Pythonie

Proces fuzzowania aplikacji można podzielić na kilka kroków:
1. Stworzenie danych wejściowych dla aplikacji na podstawie wzorca.
2. Uruchomienie aplikacji w nadzorowanym środowisku (np. z podłączonym debuggerem).
3. Załadowanie stworzonych w punkcie 1. danych do aplikacji.
4. Analiza zachowania aplikacji.
a. Gdy aplikacja zachowuje się stabilnie (powrót do punktu 2.).
b. Gdy aplikacja zachowuje się niestabilnie – zalogowanie błędu.
5. Końcowa analiza znalezionych błędów.

Każdy z tych punktów wymaga niezależnych narzędzi. Każde z narzędzi często wymaga też modyfikacji, w zależności od aplikacji, która ma być celem fuzzowania. Tworzenie danych wejściowych może być tak proste, jak tylko zmiany pojedynczych bitów/bajtów (dumb fuzzing) lub tak złożonym jak analiza danego formatu i zmiana tylko interesujących nas elementów (smart fuzzing). Niezależnie od wybranej strategii, generowanie danych za pomocą Pythona jest zadaniem stosunkowo łatwym. Stworzenie nadzorowanego środowiska wymaga dokładnej znajomości zagadnień z wielu dziedzin (protokołów sieciowych, architektury systemów operacyjnych, błędów bezpieczeństwa, reverse engineeringu, etc.). Najczęściej stosowanymi mechanizmami do nadzorowania aplikacji, jako procesu systemowego, są debuggery oraz monitory sieciowe (np. Wireshark). Tworzenie własnych debuggerów jest czasochłonne, ale pozwala na pełną kontrolę uruchomionej aplikacji. Dodatkowym atutem stosowania własnych debuggerów jest możliwość automatycznej analizy odnalezionego błędu, co skraca znacząco czas pracy researchera. Analiza wyników jest zadaniem niepowtarzalnym. Każda aplikacja/biblioteka może generować wyniki w innym formacie (core dump, plik tekstowy JVM, wyniki z własnego debuggera). Python jest doskonałym narzędziem do pisania własnych analizatorów plików wynikowych i wydobywania z nich istotnych szczegółów.

### Sulley

Sulley [9] jest frameworkiem przeznaczonym do fuzzowania aplikacji. Jest on w całości napisany w Pythonie. Jego niewątpliwymi zaletami są prostota oraz kompleksowość. Pozwala on na tworzenie w intuicyjny sposób reprezentacji danych (request), które później są wykorzystywane w sesjach fuzzowania. Sulley zawiera wbudowane agenty, które pozwalają na monitorowanie środowiska:
* network_monitor.py - logowanie komunikacji sieciowej do plików PCAP.
* process_monitor.py - pozwala na monitorowanie fuzzowanego procesu.
* etc.
Dodatkowym atutem jest wbudowany serwer HTTP, pozwalający śledzić postępy fuzzowania. Jest to proste, ale potężne narzędzie, z którym definitywnie warto się zapoznać. Często może stanowić pierwszy krok w rozpoczęciu procesu testowania danej aplikacji. Sulley jest jednym z ważniejszych frameworków wykorzystywanych przez security researcherów w ich pracy.

### FuzzMyApp Fuzzing Framework „FFF”

W FuzzMyApp rozwijamy własny framework, używany przez nas w czasie fuzzowania aplikacji. Powodem podjęcia takiej decyzji było ciągłe napotykanie powtarzalnych problemów, które wybitnie nadawały się do automatyzacji. Framework jest stworzony całkowicie w Pythonie 2.x. Jego głównymi zadaniami są:
* Tworzenie zbioru danych wejściowych, dla zadanych strategii mutacji.
* Uruchamianie aplikacji w nadzorowanym środowisku.
* Agregacja i sortowanie wyników zebranych w czasie sesji fuzzowania.
* Wstępna analiza odnalezionych podatności.
* Generacja statystyk dla sesji fuzzowania.
* Wielozadaniowość.

Wielozadaniowość w naszym kontekście oznacza dany scenariusz testowy. Czyli przykładowo fuzzowanie danego formatu pliku dla konkretnej aplikacji. System stworzony jest w taki sposób, by wykonać jak najwięcej powtarzalnych zadań, pozostawiając researcherowi/reverserowi analizę odkrytych podatności. Większość tych zadań nie jest krytyczna czasowo, wiec zdecydowaliśmy się właśnie na Pythona, w celu szybkiej i przyjemnej implementacji naszego frameworku. Decyzja o wykorzystaniu Pythona została również podjęta dzięki tak dużej liczbie zewnętrznych narzędzi/bibliotek, które znacząco ułatwiają pracę. Framework został napisany w sposób modułowy, dzięki czemu jego dostosowanie do nowej aplikacji wymaga minimalnego nakładu pracy.

### Fuzzowanie aplikacji napisanych w Javie

Jednym z napotkanych problemów podczas pracy w FuzzMyApp było stworzenie narzędzi do fuzzowania aplikacji napisanych w Javie.
Proces ten podzieliliśmy na dwie części:
1. Znalezienie potencjalnych niebezpiecznych metod.
2. Stworzenie kodu fuzzującego dla metod znalezionych w punkcie 1.

Punkt 2 został rozwiązany poprzez stworzenie dedykowanego generatora kodu Javy, który importował interesujące nas klasy i fuzzował wskazane metody. Generacja kodu Javy oraz jego kompilacja została zaimplementowana jako skrypt Pythona, bazujący na pliku wzorcowym. Sam proces fuzzowania odbywał się poprzez uruchomienie wszystkich wygenerowanych plików klas. Dodatkowym ułatwieniem było samo zachowanie JVM, która zrzuca bardzo opisowe tekstowe pliki dump w wypadku nieobsłużonego błędu w samej wirtualnej maszynie Javy. Aby znaleźć metody, które moglibyśmy poddać fuzzowaniu, postanowiliśmy statycznie analizować bytecode Java. W tym celu stworzyliśmy dedykowane narzędzie w Pythonie, w oparciu o dokumentację specyfikacji JVM. Do tego zadania doskonale nadaje się moduł struct. Naszym celem nie było odtworzenie pełnej specyfikacji, lecz tylko stworzenie narzędzia, pozwalającego wydobyć sygnatury metod dostępnych w danej klasie.
Dzięki tym sygnaturom mogliśmy przefiltrować listę dostępnych metod i wybrać tylko te, które:
a. przyjmowały parametry (metody bezparametrowe nie mogą być fuzzowane).
b. były metodami publicznymi (brak potrzeby wykorzystania refleksji).
c. były metodami zaimplementowanym natywnie (słowo kluczowe native) przy pomocy JNI.

Takie podejście okazało się dużym sukcesem. Udało nam się znaleźć błędy bezpieczeństwa m.in. w JRE7 oraz JOAL:
* FMA-2013-010 [10] – wiele błędów w JRE7. Oracle nie uznał ich jako błędy bezpieczeństwa, w przeciwieństwie do firmy specjalizującej się w Vulnerability Research - Beyond Security [11].
* FMA-2012-038 [12] (CVE-2013-4099) – prawie 70 błędów Remote Code Execution w projekcie JOAL (OpenAL.dll). Nasza praca doprowadziła do największego przeglądu bezpieczeństwa projektu [13].

Wykorzystanie Pythona pozwoliło na pełną automatyzację procesu, którego czas oscylował wokół kilkunastu godzin ciągłej pracy.

## Emulacja CPU IA-32 - PyEmu

PyEmu [14] jest emulatorem dla procesora o architekturze IA-32 napisanym w Pythonie. Wprowadza abstrakcję na procesor oraz pamięć procesu. Podobnie jak Immunity Debugger oraz IDAPython dla produktu IDA, stanowi kolejny framework umożliwiający tworzenie nowych narzędzi do dynamicznej analizy kodu w oparciu o warstwę abstrakcji, jaką jest emulator procesora.

## Podsumowanie

Niniejszy artykuł jest tylko wstępem do problemu wyszukiwania błędów bezpieczeństwa w aplikacjach, frameworkach, bibliotekach i samych systemach operacyjnych. Jest to zagadnienie pełne problemów i wyzwań, w których znacząco pomaga zastosowanie Pythona jako języka programowania. Dodatkowym atutem jest liczna baza narzędzi zaimplementowanych i dostępnych publicznie w tym języku. Narzędzia napisane w Pythonie w łatwy sposób można szybko modyfikować i przystosowywać do nowych zastosowań.
Python jest fantastycznie prostym, czytelnym, jednakże potężnym językiem programowania. Pisząc obiektowo/proceduralnie w innych językach może nam brakować wielu elementów w Pythonie, jednak przeważnie znajdzie się sposób na ich analogiczną reprezentację. Python umożliwia budowanie i utrzymywanie nie tylko prostych skryptów ale i dużych obiektowych rozwiązań. Jednak przy dużych rozwiązaniach warto trzymać się sprawdzonych procesów produkcji i utrzymania oprogramowania i … pisać dużo testów jednostkowych! Czasami pełen dynamizm oraz prostota w Pythonie może być negatywnym czynnikiem, jeśli mamy duże rozwiązanie z n warstwami abstrakcji. Brak prostych mechanizmów definiowania zakresu widoczności bądź wymuszania implementacji, innych niż rzucanie wyjątkami w czasie runtime. Jednak powyższe aspekty (zalety/wady) Pythona pozostawmy na kuluarowe dyskusje, do których serdecznie zapraszamy.

## Referencje

* [1] Linki MSDN Debugging Reference
\hyphenatedurl{http://msdn.microsoft.com/en-us/library/windows/desktop/ms679304(v=vs.85).aspx}
* [2] Structured Exception Handling
\hyphenatedurl{http://msdn.microsoft.com/en-us/library/windows/desktop/ms680660(v=vs.85).aspx}
* [3] SEH Exception Codes
\hyphenatedurl{http://msdn.microsoft.com/en-us/library/windows/desktop/aa363082(v=vs.85).aspx}
* [4] PyDBG
\hyphenatedurl{https://github.com/OpenRCE/pydbg}
* [5] Immunity Debugger
\hyphenatedurl{http://www.immunityinc.com/products/debugger}
* [6] OllyDbg
\hyphenatedurl{http://www.ollydbg.de}
* [7] IDAPython
\hyphenatedurl{http://code.google.com/p/idapython}
* [8] IDA
\hyphenatedurl{https://www.hex-rays.com}
* [9] Sulley
\hyphenatedurl{https://github.com/OpenRCE/sulley}
* [10] \hyphenatedurl{http://www.fuzzmyapp.com/pl/advisories.html}
* [11] \hyphenatedurl{http://www.securiteam.com/securitynews/5DP3K0AAVA.html}
* [12] \hyphenatedurl{http://www.fuzzmyapp.com/advisories/FMA-2012-038/FMA-2012-038-PL.xml}
* [13] \hyphenatedurl{https://www.jogamp.org/blog/index1.html}
* [14] PyEmu
\hyphenatedurl{http://code.google.com/p/pyemu}

<!-- Przeczytane: Piotr Kasprzyk -->
