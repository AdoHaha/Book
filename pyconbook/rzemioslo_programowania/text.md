# Rzemiosło programowania
## Adam Kaliński

Podczas gdy project manager koncentruje się na dostarczeniu produktu zgodnego z oczekiwaniami klienta, my programiści powinniśmy koncentrować się na tworzeniu wysokiej jakości oprogramowania. Niestety, nie jest to jednoznaczne. Jest mnóstwo projektów, które przez lata działają bezawaryjnie, zgodnie z oczekiwaniami, ale nikt nie jest w stanie ich rozwijać ze względu na m. in. nieczytelny i nieudokumentowany kod. Często o dobrych praktykach zapominamy, gdy zbliża się deadline. Poniższy artykuł podpowiada kilka sposobów na utrzymanie wysokiej jakości wytwarzanego oprogramowania.


### Problem

Dla mnie programowanie jest rzemiosłem. Gdy szukam stolarza, by zrobił mi szafkę do kuchni, przede wszystkim patrzę, czy jego warsztat jest utrzymywany w porządku. To nie jest tylko kwestia estetyki - doświadczony rzemieślnik zawsze wie, gdzie są jego narzędzia. Dzięki temu proces jego pracy jest o wiele bardziej przewidywalny. Mniej niespodzianek to mniej frustracji, więc i mniej błędów. Jest też czas, aby na bieżąco poprawiać wszystkie niedoróbki, zamiast je ukrywać z nadzieją, że w końcowym produkcie nie będzie ich widać.
Podobnie jest z programistami. Doświadczony programista wie, że w jego pracy, obok dodawania kolejnych funkcji, musi być też czas na zadbanie o swoje środowisko. Środowiskiem pracy dla programisty nie jest stół, na którym stoi monitor, klawiatura, myszka i kubki po kawie z ostatniego miesiąca. Naszym środowiskiem jest nasz kod i to, jak jest zorganizowany, biblioteki, których używamy, skrupulatnie prowadzona dokumentacja, itd. Niemniej istotne są też relacje między członkami zespołu. Chyba głównym grzechem niedoświadczonego rzemieślnika jest niedocenienie tego, czym jest warsztat. Często bagatelizujemy problem myśląc, że jest nieistotny i na sprzątanie znajdzie się czas. Niestety, tak nie jest dlatego, że nie można go rozwiązać jednorazowo. Czym innym jest "sprzątać", a czym innym "utrzymywać" porządek.

### Porządek

Zacznijmy od tego, jak definiujemy porządek? Czym on jest? Jeśli mówimy o tym, że mamy porządek w pokoju, to najczęściej rozumiemy przez to, że nie walają się po nim brudne gacie i jesteśmy w stanie dość precyzyjnie określić, gdzie każda rzecz się znajduje. W projekcie jest tak samo. Gdy trzeba coś zmienić, bądź naprawić w konkretnej funkcji - nie powinno sprawiać problemów znalezienie odpowiedzialnego za tę funkcję kodu. Nie lubimy też, gdy ktoś w kodzie zostawia swoje "brudy", jak mieszanie wcięć spacjami i tabulatorami, niekończące się “jednolinijkowce”, itd.
O ile poprawna architektura rozwiązania wiąże się z jakąś metodyką i doświadczeniem oraz ciężko ją zmierzyć - tak druga, czyli niepoprawna, jest tylko i wyłącznie kwestią niechlujstwa i zmierzyć ją łatwo.

### PEP8

Jedną z najczęściej wymienianych zalet Pythona jest składnia, która poniekąd wymusza czytelność. Mało kto zastanawia się, co by było z tą czytelnością, gdyby np. każdy programista pisał kod z wcięciami różnej długości. Kod mógłby być zupełnie poprawny z punktu widzenia interpretera, ale praca z takim mieszanym kodem byłaby męką! Dlatego powstał dokument PEP8. W zasadzie, to dzięki niemu ludzie na różnych krańcach świata są w stanie pracować nad jednym kodem. PEP8 jest zbiorem dobrych zasad stylistycznych, jakich programista Pythona powinien przestrzegać. Nie jest on jednak zbiorem subiektywnych zasad jakieś grupy pythonowców, ale raczej zebranym doświadczeniem całej społeczności. Mimo kontrowersyjnych zapisów, takich jak maksymalna długość linii czy ilość znaków wcięcia, są to zasady, których warto się trzymać. Każda zapisana w PEP8 reguła ma swoje racjonalne uzasadnienie, które laikowi może na początku wydawać się niedorzeczne, ale z czasem wszyscy zaczynamy je rozumieć.
Bądźmy jednak ludźmi praktycznymi. Nikt z nas nie będzie przeglądał tego dokumentu za każdym razem, gdy edytuje kod. Na pewno nikt nie będzie się go uczył na pamięć. Jako programiści wolimy napisać program, który takie sprawdzanie zrobi za nas. Tak więc powstało takich programów całkiem sporo: *pep*, *PyLint*, *PyFlakes* czy *Flake8*. Są one świetnymi narzędziami, które pozwolą nam w bardzo prosty sposób zweryfikować, czy kod jest zgodny ze standardami PEP8, czy nie. Większość popularnych edytorów ma również możliwość sprawdzania w locie, czy napisany kod jest poprawny pod względem stylistyki.
Tak więc nie jest trudno sprawdzić zgodność naszego kodu z PEP8, ale jednak tak wielu programistów nie stosuje się do tych standardów. Problem -- jak to zwykle bywa -- istnieje pomiędzy klawiaturą, a krzesłem. Zazwyczaj po prostu ignorujemy natrętne informacje i wchodzi nam to tak w krew, że przestajemy je zauważać. Tutaj trzeba podkreślić, że nie trzeba zawsze stosować się restrykcyjnie do PEP8. Ważne,by zespół ustalił swoje własne zasady i się ich trzymał.
Problem z trzymaniem się tych zasad jest taki, że jego efekty widać dopiero po jakimś czasie, więc na początku ciężko się zmobilizować. Zachęcam do tego wysiłku, bo wiem, z własnego doświadczenia, że warto.

### Złożoność

Jedna ze starych dobrych praktyk mówiła, że metoda nie powinna mieć więcej niż jeden ekran. Jest to dość prosty sposób sprawdzania, czy metoda nie jest zbyt złożona. Trzeba przyznać, że długie metody są jak zdania wielokrotnie złożone -- nie każdy je od razu zrozumie (włącznie z autorem). Często idą w parze z licznymi komentarzami tłumaczącymi, w międzyczasie, co się dzieje. Trudno się nie pogubić, a szukania w takim kodzie błędu nie życzyłbym najgorszemu wrogowi. Niestety, dzisiaj to, co u jednego programisty może zajmować pół ekranu, u drugiego może zajmować dwa. Wpływa na to użycie edytora, rozdzielczość monitora i czcionka. Dużo skuteczniejsze jest określenie stałej liczby linii, której kod nie powinien przekraczać. To dalej jest nieprecyzyjne, bo w Pythonie można użyć list składanych do zrobienia bardzo skomplikowanego kodu w jednej linii. Na szczęście, na pomoc przychodzą nam metryki takie jak złożoność cyklometryczna McCabe'a. Dostępne są narzędzia do liczenia tej złożoności automatycznie, np. wymieniony powyżej *flake8*. Warto w tym miejscu wspomnieć, że dobrą praktyką jest umieszczanie w metodach kodu na tym samym poziomie abstrakcji.


### Nazewnictwo

Jest to praca twórcza i bardzo często niedoceniana. Dobrze nazwane klasy i metody są najlepszą dokumentacją, jaka może być. Widząc dobrze napisany kod jesteśmy w stanie szybko rozpoznać, kim są aktorzy i jaką pełnią rolę w systemie. Mając problem z wyborem nazwy programista powinien zastanowić się nad tym, czy ta metoda bądź klasa nie narusza np. zasady pojedynczej odpowiedzialności. Zaskakująco częstym błędem jest nazywanie tego samego bytu na dwa lub więcej sposobów. To trochę tak, jakby zacząć pracę w kilkuosobowym zespole, gdzie każdy ma 3 imiona. Niezwykle trudno wywnioskować, kto jest za co odpowiedzialny i generalnie prowadzi to do częstych pomyłek i błędów. Ciężko wyobrazić sobie taką pracę. Niemniej jednak, często to robimy, a na myśl o poprawieniu nazewnictwa każdy kręci nosem.
Nie mniej istotne są nazwy zmiennych. Tak często korzystamy z jedno, dwu, czy trzyliterowych skrótów, które tydzień później nawet dla autora nie mają żadnego sensu. Aby zrozumieć problem, wystarczy spojrzeć na dowolną bibliotekę JavaScript, która została zminimalizowana. Cały kod traci jakąkolwiek czytelność. Często tłumaczymy się, że to nie jest skomplikowany kod, że to oszczędność miejsca, no i w ogóle - że sami to napisaliśmy, więc będziemy wiedzieli, o co chodziło. Ja sam pamiętam kod, który pisałem z takim właśnie przekonaniem i to, że już parę miesięcy później nie wiedziałem, o co w nim chodzi. Trzeba oczywiście zachować we wszystkim umiar. Czasami krótka nazwa zmiennej jest wystarczająco opisowa. Nie jest też dobrze, by nazwa zmiennej miała 20 znaków, bo szybko zorientujemy się, że logika nie mieści się na ekranie.
W przeciwieństwie do nazewnictwa klas, metod i funkcji tutaj jesteśmy w stanie dostać lepsze wsparcie ze strony narzędzi. Np. *PyLint* informuje nas o nieprawidłowych (zbyt długich lub zbyt krótkich) nazwach zmiennych. Jest to przydatne ostrzeżenie, ale jak już wspomniałem, trzeba umieć zachować umiar i nie polegać ślepo na narzędziach.

### Testy

O testach jednostkowych zostało powiedziane już tyle, że ciężko wymyślić coś odkrywczego. Jednak tak wiele projektów ma bardzo słabe pokrycie kodu testami. Dlaczego? Niestosowanie testów jest już pewnego rodzaju faux pas. Odnoszę wrażenie, że doprowadziliśmy do tego stanu, kiedy nie wypada nie pisać testów, więc robimy to byle jak. Powszechne stało się mniemanie, że lepsze słabe testy niż żadne. To prawda, ale chyba zbyt często bierzemy byle jakie testy za wystarczająco dobre. To najczęściej jest początek końca ich pisania, bo ciężko dopatrzeć się dużych korzyści w słabych testach. Dlaczego o tym piszę? Ponieważ testy pomagają dostrzec nie tylko błędy jednostkowe, ale także błędy złej architektury. Jeśli testuję metodę i muszę do tego dopisać dużo mocków, to daje mi to do zrozumienia, że moja metoda ma za dużo zależności, a więc prawdopodobnie znowu łamię zasadę pojedynczej odpowiedzialności. Trzeba więc też dbać o kod testów, nie zostawiać go samopas, jako część kodu drugiej kategorii. Należy pamiętać, że testy pokazują, jak nasz kod będzie użyty. Jeśli w testach jest używany niechlujnie, to prawdopodobnie gdzieś w kodzie będzie użyty tak samo niechlujnie.


### Dokumentacja

Dokumentacja jest bardzo niedoceniana do momentu zmian kadrowych. Okazuje się, że ciężko w krótkiej chwili przekazać ogrom wiedzy na temat wypracowanych rozwiązań reszcie zespołu lub nowemu pracownikowi. Kiedy myślimy o dokumentacji, pierwszym co nam przychodzi do głowy są zwykłe *docstringi*. Zasada mówi, że każda publiczna metoda i funkcja powinna być opatrzona komentarzem dokumentacji. Nie należy mylić jednak komentarza z dokumentacją. Dokumentacja w *docstringach* jest zawsze przydatna, bo może zostać wygenerowana do pełnej dokumentacji API i jest najlepszym do tego miejscem. Komentarze są kawałkiem tekstu, który ma nam rozjaśnić zamysł autora. Jest to niebezpieczne narzędzie, bo komentarze - w przeciwieństwie do kodu - mają tendencję do starzenia się, a nie ma nic bardziej zaciemniającego obraz, jak nieaktualny komentarz. Zawsze powinniśmy dążyć do tego, by to kod sam siebie wyjaśniał i nie potrzebował komentarza.
Są jednak takie informacje o projekcie, które nie pasują do żadnego kawałka kodu. Warto wtedy zaopatrzyć się w oddzielną dokumentację, np. wiki albo Sphinx'a [4]. Można tam umieścić opis infrastruktury, wymagania i zależności oraz cokolwiek, co jest ważne dla zrozumienia działania naszego projektu. Bardzo przydatna okazuje się jakaś baza kawałków kodu (snippets), które wykonują zadania nie na tyle częste, by pisać do nich skrypty, ale na tyle ciekawe, by nasz kolega z zespołu nie musiał po raz drugi dochodzić do tego samego rozwiązania, gdy problem się powtórzy.


### Systematyczność

Moja mama zawsze mi mówiła, że jeśli po każdej czynności obejrzę się za siebie i sprawdzę,czy pozostawiam miejsce wykonywania tej czynności w porządku, to nigdy nie będę musiał sprzątać. Było to spore uproszczenie, ale tak naprawdę, to miała bardzo dużo racji. Bądźmy szczerzy, nikt nie stwierdzi nagle, że w projekcie z paroma tysiącami linii, trzeba wprowadzić PEP8, albo dopisać testy jednostkowe. Jest to ogromna zmiana, na którą żaden biznes się nie zgodzi. Musimy starać się zachowywać wysoką jakość kodu w każdej zmianie, jaką publikujemy w repozytorium.
Obecne systemy kontroli wersji, tj. Git czy Mercurial udostępniają mnóstwo narzędzi, które warto wykorzystać. Mają one tzw. hook'i, czyli możliwość wykonywania zdefiniowanych przez użytkownika operacji, gdy zachodzą pewne zdarzenia, tj. dodanie zmiany czy wysłanie kodu do innego repozytorium. Wiele narzędzi do kontroli jakości kodu ma wbudowane hook'i, z których można od razu korzystać.

### Podsumowanie

Jesteśmy rzemieślnikami. Musimy dbać o fach, który wykonujemy. Dobry rzemieślnik wie, jak dbać o swoje środowisko pracy i wie, jakie narzędzia są mu potrzebne. Opisane powyżej metody to krótki wstęp do tego, w jaki sposób można monitorować jakość kodu - a możliwości jest wiele. Bardzo ciekawym źródłem wiedzy jest Python'owa lista mailingowa code-quality [2].


### Bibliografia

* [http://pl.wikipedia.org/wiki/Złożoność_cyklomatyczna](http://pl.wikipedia.org/wiki/Złożoność_cyklomatyczna) - Złożoność cyklometryczna
* [http://mail.python.org/mailman/listinfo/code-quality](http://mail.python.org/mailman/listinfo/code-quality) - Lista mailingowa o jakości kodu w Python'ie
* [http://pl.wikipedia.org/wiki/Metryka_oprogramowania](http://pl.wikipedia.org/wiki/Metryka_oprogramowania) - Metryki oprogramowania
* [http://sphinx-doc.org/](http://sphinx-doc.org/) - System do tworzenia dokumentacji
* [http://www.python.org/dev/peps/pep-0008/](http://www.python.org/dev/peps/pep-0008/) - PEP8 - Style Guide for Python
* Robert C. Martin - "Czysty Kod. Podręcznik dobrego programisty"
